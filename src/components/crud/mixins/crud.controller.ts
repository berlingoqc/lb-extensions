/* eslint-disable @typescript-eslint/no-explicit-any */
import {Constructor, inject, MixinTarget} from '@loopback/core';
import {
  DefaultCrudRepository,
  Entity,
  CountSchema,
  Count,
  Model,
  Where,
  Filter,
  FilterExcludingWhere,
} from '@loopback/repository';
import {
  getModelSchemaRef,
  param,
  requestBody,
  RestApplication,
} from '@loopback/rest';
import {chain, getDecoratorsProperties} from '../../../helpers';
import {
  operatorDecorator,
  parampathFunction,
  requestBodyDecoratorGetter,
} from './decorator';
import {
  CrudControllerMixinOptions,
  CrudOperators,
  InjectableRepository,
  ModelDef,
} from './model';

/**
 * Ajoute un CRUD Controller anonyme à partir d'un model qui possède un repository
 */
export const addCRUDController = <E extends Entity, ID>(
  app: RestApplication,
  // classe de l'Entité
  modelDef: ModelDef,
  // paramètre pour l'injection du repository avec @repository()
  repo: InjectableRepository<E, ID>,
  options: CrudControllerMixinOptions,
) => {
  const name =
    typeof repo === 'string'
      ? repo
      : repo instanceof DefaultCrudRepository
      ? 'null'
      : repo.name;

  class Test extends CrudControllerMixin<Constructor<object>, E, ID>(
    Object,
    modelDef,
    options,
  ) {
    constructor(
      @inject(`repositories.${name}`, {optional: true})
      crudRepository: DefaultCrudRepository<any, any, {}>,
    ) {
      super();
      if (!crudRepository) {
        if (repo instanceof DefaultCrudRepository) {
          crudRepository = repo as DefaultCrudRepository<any, any, {}>;
        } else {
          throw new Error('Cound not inject a repository');
        }
      }
      this.repository = crudRepository;
    }
  }

  const binding = app.controller(Test, `${options.name}Controller`);

  return binding.key;
};

/**
 *
 * CrudControllerMixin is a mixin to add all of the CrudOperation
 * to expose youre Repository with a controller. The function added
 * are the same as the default CRUD Controller generated by lb4-cli
 * @param superClass
 * @param repoEntity : Entity of the repository you will use
 * @param options : CrudControllerMixinOptions
 *
 * You must provide value for the following property added by the mixin
 * - repository : DefaultCrudRepository that will be use
 */
export function CrudControllerMixin<
  T extends MixinTarget<object>,
  E extends Entity,
  ID
>(
  superClass: T,
  repoEntity: Function & {prototype: any} & typeof Model,
  options: CrudControllerMixinOptions,
) {
  // base path for binding
  const basePath = `${options.basePath ?? ''}/${options.name}`;

  if (!options.id) options.id = 'id';
  if (!options.idType) options.idType = 'number';

  const omitId =
    options.omitId === undefined || options.omitId === true ? [options.id] : [];

  const isDisabled = (funcName: CrudOperators) =>
    options.disableds ? options.disableds.indexOf(funcName) > -1 : false;

  // wrap to use to correct property decorator to get id from request
  const parampath = parampathFunction(options.idType, options.id);
  const requestbody = requestBodyDecoratorGetter(repoEntity);
  class RestController extends superClass {
    repository: DefaultCrudRepository<E, ID, {}>;

    @operatorDecorator({
      op: 'POST',
      path: `${basePath}`,
      name: repoEntity.name,
      model: repoEntity,
      disabled: isDisabled('create'),
      spec: options.specs ? options.specs['create'] : undefined,
    })
    @chain(...getDecoratorsProperties(options.properties, 'create'))
    async create(
      @requestbody({exclude: omitId})
      profile: Omit<E, 'id'>,
    ): Promise<E> {
      return this.repository.create(profile as any);
    }

    @operatorDecorator({
      op: 'GET',
      path: `${basePath}/count`,
      name: repoEntity.name,
      customSchema: CountSchema,
      disabled: isDisabled('count'),
      spec: options.specs ? options.specs['count'] : undefined,
    })
    @chain(...getDecoratorsProperties(options.properties, 'count'))
    async count(@param.where(repoEntity) where?: Where<E>): Promise<Count> {
      return this.repository.count(where);
    }

    @operatorDecorator({
      op: 'GET',
      path: `${basePath}`,
      name: repoEntity.name,
      customSchema: {
        type: 'array',
        items: getModelSchemaRef(repoEntity, {includeRelations: true}),
      },
      disabled: isDisabled('find'),
      spec: options.specs ? options.specs['find'] : undefined,
    })
    @chain(...getDecoratorsProperties(options.properties, 'find'))
    async find(@param.filter(repoEntity) filter?: Filter<E>): Promise<E[]> {
      return this.repository.find(filter);
    }

    @operatorDecorator({
      op: 'PATCH',
      path: `${basePath}`,
      name: repoEntity.name,
      customSchema: CountSchema,
      requestDescription: 'PATCH success count',
      disabled: isDisabled('updateAll'),
      spec: options.specs ? options.specs['updateAll'] : undefined,
    })
    @chain(...getDecoratorsProperties(options.properties, 'updateAll'))
    async updateAll(
      @requestbody({partial: true})
      profile: E,
      @param.where(repoEntity) where?: Where<E>,
    ): Promise<Count> {
      return this.repository.updateAll(profile, where);
    }

    @operatorDecorator({
      op: 'GET',
      path: `${basePath}/{id}`,
      name: repoEntity.name,
      customSchema: getModelSchemaRef(repoEntity, {includeRelations: true}),
      disabled: isDisabled('findById'),
      spec: options.specs ? options.specs['findById'] : undefined,
    })
    @chain(...getDecoratorsProperties(options.properties, 'findById'))
    async findById(
      @parampath() id: ID,
      @param.filter(repoEntity, {exclude: 'where'})
      filter?: FilterExcludingWhere<E>,
    ): Promise<E> {
      return this.repository.findById(id, filter);
    }

    @operatorDecorator({
      op: 'PATCH',
      path: `${basePath}/{id}`,
      name: repoEntity.name,
      customSchema: {},
      defaultResponse: '204',
      responseDescription: 'Entity PATCH success',
      disabled: isDisabled('updateById'),
      spec: options.specs ? options.specs['updateById'] : undefined,
    })
    @chain(...getDecoratorsProperties(options.properties, 'updateById'))
    async updateById(
      @param.path.string('id') id: ID,
      @requestbody({partial: true, exclude: omitId})
      profile: E,
    ): Promise<void> {
      await this.repository.updateById(id, profile);
    }

    @operatorDecorator({
      op: 'PUT',
      path: `${basePath}/{id}`,
      name: repoEntity.name,
      customSchema: {},
      defaultResponse: '204',
      disabled: isDisabled('replaceById'),
      spec: options.specs ? options.specs['replaceById'] : undefined,
    })
    @chain(...getDecoratorsProperties(options.properties, 'replaceById'))
    async replaceById(
      @param.path.string('id') id: ID,
      @requestBody() profile: E,
    ): Promise<void> {
      await this.repository.replaceById(id, profile);
    }

    @operatorDecorator({
      op: 'DELETE',
      path: `${basePath}/{id}`,
      name: repoEntity.name,
      customSchema: {},
      responseDescription: 'DELETE success',
      defaultResponse: '204',
      disabled: isDisabled('deleteById'),
      spec: options.specs ? options.specs['deleteById'] : undefined,
    })
    @chain(...getDecoratorsProperties(options.properties, 'deleteById'))
    async deleteById(@param.path.string('id') id: ID): Promise<void> {
      await this.repository.deleteById(id);
    }
  }

  return RestController;
}
