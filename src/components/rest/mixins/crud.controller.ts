/* eslint-disable @typescript-eslint/no-explicit-any */
import {Constructor, MixinTarget} from '@loopback/core';
import {
  DefaultCrudRepository,
  Entity,
  CountSchema,
  Count,
  Model,
  Where,
  Filter,
  FilterExcludingWhere,
  repository,
  Class,
  Repository,
} from '@loopback/repository';
import {
  del,
  get,
  getModelSchemaRef,
  HttpErrors,
  param,
  patch,
  post,
  put,
  requestBody,
  RestApplication,
} from '@loopback/rest';
import {
  chain,
  ControllerMixinOptions,
  getDecoratorsProperties,
} from '../../../helpers';

export type ModelDef = Function & {prototype: any} & typeof Model;

export interface CrudControllerMixinOptions extends ControllerMixinOptions {
  name: string;
  id: string;
  idType: string;
}

// Decorator to add to an operation that
// you don't wont to be enable
export function disable() {
  return (target: any, key: string, descriptor: any) => {
    descriptor.value = function () {
      throw new HttpErrors.NotExtended();
    };

    return descriptor;
  };
}

export const getCRUDController = <E extends Entity, ID>(
  app: RestApplication,
  modelDef: ModelDef,
  repo: string | Class<Repository<Model>>,
  options: CrudControllerMixinOptions,
) => {
  class Test extends CrudControllerMixin<Constructor<object>, E, ID>(
    Object,
    modelDef,
    options,
  ) {
    constructor(
      @repository(repo)
      theRepository: DefaultCrudRepository<any, any, {}>,
    ) {
      super();
      this.repository = theRepository;
    }
  }

  app.controller(Test);
};

/**
 *
 * CrudControllerMixin is a mixin to add all of the CrudOperation
 * to expose your Repository with a controller. The function added
 * are the same as the default CRUD Controller generated by lb4-cli
 * @param superClass
 * @param repoEntity : Entity of the repository you will use
 * @param options : CrudControllerMixinOptions
 *
 * You must provide value for the following property added by the mixin
 * - repository : DefaultCrudRepository that will be use
 */
export function CrudControllerMixin<
  T extends MixinTarget<object>,
  E extends Entity,
  ID
>(
  superClass: T,
  repoEntity: Function & {prototype: any} & typeof Model,
  options: CrudControllerMixinOptions,
) {
  // base path for binding
  const basePath = `${options.basePath ?? ''}/${options.name}`;

  // wrap to use to correct property decorator to get id from request
  function parampath() {
    return (target: object, member: string, index: number) => {
      switch (options.idType) {
        case 'string':
          return param.path.string(options.id)(target, member, index);
        case 'number':
          return param.path.number(options.id)(target, member, index);
        default:
          throw new HttpErrors.UnprocessableEntity(
            'ID must be string or number',
          );
      }
    };
  }
  class RestController extends superClass {
    repository: DefaultCrudRepository<E, ID, {}>;

    other: number;

    @post(basePath, {
      responses: {
        '200': {
          description: 'Create model instance',
          content: {
            'application/json': {schema: getModelSchemaRef(repoEntity)},
          },
        },
      },
    })
    @chain(...getDecoratorsProperties(options.properties))
    async create(
      @requestBody({
        content: {
          'application/json': {
            schema: getModelSchemaRef(repoEntity, {
              title: 'NewEntity',
              exclude: ['id'],
            }),
          },
        },
      })
      profile: Omit<E, 'id'>,
    ): Promise<E> {
      return this.repository.create(profile as any);
    }

    @get(basePath + '/count', {
      responses: {
        '200': {
          description: 'Profile model count',
          content: {'application/json': {schema: CountSchema}},
        },
      },
    })
    @chain(...getDecoratorsProperties(options.properties))
    async count(@param.where(repoEntity) where?: Where<E>): Promise<Count> {
      return this.repository.count(where);
    }

    @get(basePath, {
      responses: {
        '200': {
          description: 'Array of Profile model instances',
          content: {
            'application/json': {
              schema: {
                type: 'array',
                items: getModelSchemaRef(repoEntity, {includeRelations: true}),
              },
            },
          },
        },
      },
    })
    @chain(...getDecoratorsProperties(options.properties))
    async find(@param.filter(repoEntity) filter?: Filter<E>): Promise<E[]> {
      return this.repository.find(filter);
    }

    @patch(basePath, {
      responses: {
        '200': {
          description: 'PATCH success count',
          content: {'application/json': {schema: CountSchema}},
        },
      },
    })
    @chain(...getDecoratorsProperties(options.properties))
    async updateAll(
      @requestBody({
        content: {
          'application/json': {
            schema: getModelSchemaRef(repoEntity, {partial: true}),
          },
        },
      })
      profile: E,
      @param.where(repoEntity) where?: Where<E>,
    ): Promise<Count> {
      return this.repository.updateAll(profile, where);
    }

    @get(basePath + '/{id}', {
      responses: {
        '200': {
          description: 'Entity model instance',
          content: {
            'application/json': {
              schema: getModelSchemaRef(repoEntity, {includeRelations: true}),
            },
          },
        },
      },
    })
    @chain(...getDecoratorsProperties(options.properties))
    async findById(
      @parampath() id: ID,
      @param.filter(repoEntity, {exclude: 'where'})
      filter?: FilterExcludingWhere<E>,
    ): Promise<E> {
      return this.repository.findById(id, filter);
    }

    @patch(basePath + '/{id}', {
      responses: {
        '204': {
          description: 'Entity PATCH success',
        },
      },
    })
    @chain(...getDecoratorsProperties(options.properties))
    async updateById(
      @param.path.string('id') id: ID,
      @requestBody({
        content: {
          'application/json': {
            schema: getModelSchemaRef(repoEntity, {partial: true}),
          },
        },
      })
      profile: E,
    ): Promise<void> {
      await this.repository.updateById(id, profile);
    }

    @put(basePath + '/{id}', {
      responses: {
        '204': {
          description: 'Profile PUT success',
        },
      },
    })
    @chain(...getDecoratorsProperties(options.properties))
    async replaceById(
      @param.path.string('id') id: ID,
      @requestBody() profile: E,
    ): Promise<void> {
      await this.repository.replaceById(id, profile);
    }

    @del(basePath + '/{id}', {
      responses: {
        '204': {
          description: 'Entity DELETE success',
        },
      },
    })
    @chain(...getDecoratorsProperties(options.properties))
    async deleteById(@param.path.string('id') id: ID): Promise<void> {
      await this.repository.deleteById(id);
    }
  }

  return RestController;
}
